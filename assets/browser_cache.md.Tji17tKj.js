import{_ as a,c as e,o as t,a4 as s}from"./chunks/framework.M0jMQRpf.js";const n="/assets/size.D3ITopaM.png",r="/assets/refresh.DLKnJlHG.jpg",g=JSON.parse('{"title":"浏览器缓存","description":"","frontmatter":{},"headers":[],"relativePath":"browser/cache.md","filePath":"browser/cache.md"}'),o={name:"browser/cache.md"},d=s('<h1 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>简单来说，浏览器缓存就是把一个已经请求过的Web资源（如html，图片，js）拷贝一份副本储存起来。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求<br> 缓存是根据url来处理的，只要url不一样就是新的资源。</p><h2 id="浏览器缓存的位置一般可以分为三类" tabindex="-1">浏览器缓存的位置一般可以分为三类 <a class="header-anchor" href="#浏览器缓存的位置一般可以分为三类" aria-label="Permalink to &quot;浏览器缓存的位置一般可以分为三类&quot;">​</a></h2><p>1.Memory Cache（内存缓存）：这是最快的一种缓存，因为数据直接存储在浏览器的内存中。当浏览器需要某个资源时，会首先检查内存缓存中是否存在。如果存在，则直接从内存中加载，速度非常快。但需要注意的是，<code>内存缓存的生命周期很短，随着页面的关闭或浏览器的退出，内存缓存中的数据会被清空</code>，一般<code>脚本、字体、图片</code>等经常使用的资源会存在内存当中，因为脚本可能会随时执行，如果把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的IO开销比较大。<br></p><p>2.Disk Cache（硬盘缓存）：当内存缓存中没有找到所需的资源时，浏览器会检查硬盘缓存。硬盘缓存的数据存储在用户的硬盘上，因此其生命周期相对较长，即使关闭浏览器或重启计算机，硬盘缓存中的数据仍然会保留。<code>硬盘缓存的读取速度虽然比内存缓存慢，但仍然比从服务器重新请求资源要快得多</code>，一般不常用的资源如css会存到硬盘中，因为css样式加载一次即可渲染出页面。<br></p><p>3.Server Request（服务器请求）：如果内存缓存和硬盘缓存中都没有找到所需的资源，浏览器会向服务器发送请求，从服务器获取资源。一旦资源被成功获取，浏览器会将其存储在硬盘缓存中，以便将来快速访问。<br></p><p>计算机中的内存一定比硬盘容量小得多，一般内存中存储体积小使用频率高的文件，磁盘中存储体积大使用频率低的文件<br> Disk Cache的一个资源如果短时间内多次使用会转换为Memory Cache，如果发现network中的一个资源的size是Disk Cache，刷新两次页面会发现变成了Memory Cache，间隔一段时间再刷新页面会发现又变成了Disk Cache，例如<a href="https://cloud.tencent.com/developer/article/2195574?areaSource=102001.7&amp;traceId=4iyLeRnchPQJJwd40Qqi4" target="_blank" rel="noreferrer">这个页面</a>的<a href="https://developer.qcloudimg.com/http-save/yehe-2131069/5ecf4aa684a910da8c6e2d3328ef47c6.png" target="_blank" rel="noreferrer">这个资源</a></p><h3 id="匹配优先级-三级缓存原理" tabindex="-1">匹配优先级(三级缓存原理)： <a class="header-anchor" href="#匹配优先级-三级缓存原理" aria-label="Permalink to &quot;匹配优先级(三级缓存原理)：&quot;">​</a></h3><p>浏览器读取命中缓存资源的顺序为memory cache -&gt; disk cache<br> 先去内存看，如果有，直接加载；<br> 如果内存没有，则取硬盘获取，如果有直接加载；<br> 如果硬盘也没有，那么就进行网络请求；<br> 加载到的资源缓存到硬盘或内存。<br></p><p>浏览器的三级缓存机制确保了浏览器在加载页面时能够优先从最快的缓存中获取资源，从而提高了页面加载速度和用户体验。同时，通过缓存机制，也减少了不必要的网络请求和带宽消耗，降低了服务器的负载。<br></p><h3 id="浏览器network的size栏" tabindex="-1">浏览器Network的Size栏 <a class="header-anchor" href="#浏览器network的size栏" aria-label="Permalink to &quot;浏览器Network的Size栏&quot;">​</a></h3><p>在浏览器开发者工具的Network的Size栏会出现的三种情况：<br> from memory cache<br> from disk cache<br> 资源本身大小数值：当http状态为200是实实在在从浏览器获取的资源（比如：13.6K），当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的<br><img src="'+n+`" width="100%"></p><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><p>强缓存（无HTTP请求，无需协商）<br> 直接读取本地缓存，无需跟服务端发送请求确认，http返回状态码是200（from memory cache或者from disk cache）。<br></p><p>Expires是HTTP响应头的一个字段 Cache-Control既可以是请求头也可以是响应头</p><table><thead><tr><th>Http Request header</th><th>Http Response header</th><th>http版本</th><th>http status</th><th>优先级</th></tr></thead><tbody><tr><td></td><td>Expires: Wed, 17 Apr 2024 02:28:49 GMT</td><td>http1.0</td><td>200</td><td>低</td></tr><tr><td>Cache-Control:max-age=86400(秒)</td><td>Cache-Control:max-age=86400(秒)</td><td>http1.1</td><td>200</td><td>高</td></tr></tbody></table><h2 id="协商缓存-有http请求-需协商" tabindex="-1">协商缓存（有HTTP请求，需协商） <a class="header-anchor" href="#协商缓存-有http请求-需协商" aria-label="Permalink to &quot;协商缓存（有HTTP请求，需协商）&quot;">​</a></h2><p>浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的，需要向服务器询问，如果服务器认为浏览器的缓存版本未过期还可用，那么便会返回304（Not Modified）状态码，304的时候返回的是体积小的报文不是文件实际的大小，可以节省请求需要的<code>rtt</code>。</p><table><thead><tr><th>Http request header(请求头)</th><th>Http response header(响应头)</th><th>http版本</th><th>http status</th><th>优先级</th></tr></thead><tbody><tr><td>If-Modified-Since: Thu, 11 Apr 2024 02:45:32 GMT</td><td>Last-Modified:Thu, 11 Apr 2024 02:45:32 GMT</td><td>http1.0</td><td>304</td><td>低</td></tr><tr><td>If-None-Match: &quot;948c6463e014712e4df554f4c14ed62c&quot;</td><td>Etag:&quot;948c6463e014712e4df554f4c14ed62c&quot;</td><td>http1.1</td><td>200</td><td>高</td></tr></tbody></table><p>有了Last-Modified为什么还要Etag？因为<br> 1、Last-Modified只能精确到秒(或者说UNIX记录MTIME只能精确到秒)，如果在1秒内多次修改文件，last-modified无法判断<br> 2、有些文件更新了但是内容未变化（例如备份文件，重新打包生成的内容未变化的js文件），即使文件内容没有发生变化，其修改时间也可能会更新<br></p><p>有了Etag为什么还要Last-Modified?因为<br> 对于例如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。</p><p>所以Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h2 id="浏览器自带的启发式缓存" tabindex="-1">浏览器自带的启发式缓存 <a class="header-anchor" href="#浏览器自带的启发式缓存" aria-label="Permalink to &quot;浏览器自带的启发式缓存&quot;">​</a></h2><p>这是一种在没有显式指定缓存控制策略的情况下，浏览器尝试性地重用之前获取的资源的方法。它基于一些启发式规则（如资源的修改时间、内容大小等）来判断缓存的有效期。然而，由于启发式缓存的不可靠性和不一致性，现代Web开发中更推荐使用显式的缓存控制指令（如Cache-Control和Expires头部）来管理资源的缓存行为。</p><p>根据响应头中的date和last-modified字段计算缓存时间：<br> 公式为：( Date - Last-Modified ) * 0.1<br> Date：当前请求的时间<br> Last-Modified：服务器中资源最后被修改的日期<br></p><p><code>在服务器明确指定了缓存策略（如Cache-Control）或缓存过期时间（如Expires）的情况下，浏览器会优先遵循服务器的指示，启发式缓存不会生效。只有在服务器未明确指定缓存策略或者缓存过期时间的情况下，启发式缓存才会生效</code>。</p><p>所以，如果你设置了协商缓存（即设置了Last-Modified或者ETag），但没有设置缓存策略或者缓存过期时间，那么启发式缓存可能会生效。如果你同时设置了协商缓存和缓存策略或者缓存过期时间，那么启发式缓存就不会生效。</p><h2 id="cache-control" tabindex="-1">cache-control <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;cache-control&quot;">​</a></h2><p>cache-control中： no-cache(相当于max-age=0) 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用  no-store</p><table><thead><tr><th>Cache-Control</th><th>描述</th></tr></thead><tbody><tr><td>no-store</td><td>彻底禁用缓存，强缓存、协商缓存、浏览器自带的启发式缓存都不生效了，每次都从服务器获取</td></tr><tr><td>no-cache等价于max-age:0 等价于Pragma: no-cache</td><td>资源被缓存,但是缓存立刻过期, 同时下次访问时强制验证资源有效性(如果有协商缓存，会根据协商缓存来验证有效性)</td></tr><tr><td>max-age</td><td>缓存资源, 但是在指定时间(单位为秒)后缓存过期</td></tr></tbody></table><h3 id="避免重新验证immutable" tabindex="-1">避免重新验证immutable <a class="header-anchor" href="#避免重新验证immutable" aria-label="Permalink to &quot;避免重新验证immutable&quot;">​</a></h3><p><a href="https://bitsup.blogspot.com/2016/05/cache-control-immutable.html" target="_blank" rel="noreferrer">immutable的mdn说明</a><br> 然而，即使你设置了长max-age，当用户重新加载页面时（例如，通过点击浏览器的刷新按钮），浏览器仍然会向服务器发送一个条件请求来检查资源是否有所改变。这种请求通常包含一个If-None-Match或If-Modified-Since头，以询问服务器资源是否自从上次请求以来有所更新，虽然这些请求会返回304，但是当请求数量多时会增加大量时间和大量带宽。<br> 为了进一步优化这种场景，HTTP/1.1规范引入了immutable指令。当服务器在Cache-Control响应头中使用immutable指令时，它明确告诉浏览器这个资源是永远不会改变的，因此浏览器无需在重新加载页面时发送条件请求来验证资源是否更新。这可以进一步减少不必要的网络流量，提高页面加载速度。<br></p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Cache-Control: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">max-age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=365000000, immutable</span></span></code></pre></div><h2 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h2><p>对于一般的资源js、css、图片，每次打包根据hash值生成新的文件名，这样加载的时候url就和之前不同，缓存是根据url来缓存的，url变化了这样就能获取最新的资源了，这样我们就可以放心使用 Cache-Control 配置一个很大的 max-age=31536000 (一年)，不怕强缓存。</p><p>对于没有hash值的文件，例如html，我们通过设置<code>Cache-Control: no-cache</code>，使浏览器每次都请求服务器，利用协商缓存配合 ETag 或者 Last-Modified 来验证资源是否有效，来保证获取的是最新的文件</p><h3 id="nginx配置" tabindex="-1">nginx配置 <a class="header-anchor" href="#nginx配置" aria-label="Permalink to &quot;nginx配置&quot;">​</a></h3><p>在 nginx.conf 中配置以下内容：</p><div class="language-conf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">conf</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>server {  </span></span>
<span class="line"><span>    listen 80;  </span></span>
<span class="line"><span>    server_name your_domain.com; # 替换为您的域名  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    root /var/www/html; # 替换为您的web根目录  </span></span>
<span class="line"><span>    index index.html;  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    # html设置成走协商缓存</span></span>
<span class="line"><span>    location ~* \\.(html)$ {  </span></span>
<span class="line"><span>        add_header Cache-Control &quot;no-cache&quot;;  </span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    # js、css\\png等设置强缓存</span></span>
<span class="line"><span>    location ~* \\.(js|css|png|jpg|jpeg|gif|gz|svg|mp4|xml|woff)$ {  </span></span>
<span class="line"><span>        expires 1h; # 1小时，即3600秒  </span></span>
<span class="line"><span>        add_header Cache-Control &quot;max-age=360000&quot;; # 默认4天</span></span>
<span class="line"><span>        #add_header Cache-Control no-store; # 不缓存 但是不推荐 浏览器自带的优化功能用不了了</span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    # 这个块专门用于匹配config.js文件</span></span>
<span class="line"><span>    location = /config.js {  </span></span>
<span class="line"><span>        add_header Cache-Control &quot;no-cache&quot;;  </span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    # 默认块，用于处理其他所有请求</span></span>
<span class="line"><span>    location / {  </span></span>
<span class="line"><span>        try_files $uri $uri/ =404;  </span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="测试不同浏览器刷新方式对请求头的影响" tabindex="-1">测试不同浏览器刷新方式对请求头的影响 <a class="header-anchor" href="#测试不同浏览器刷新方式对请求头的影响" aria-label="Permalink to &quot;测试不同浏览器刷新方式对请求头的影响&quot;">​</a></h2><p><img src="`+r+'" width="50%"><br></p><table><thead><tr><th>重新加载方式</th><th>请求头</th><th>响应头</th><th>是否清除缓存 ｜</th></tr></thead><tbody><tr><td>正常重新加载(command+r)</td><td>If-Modified-Since: Thu, 11 Apr 2024 02:45:32 GMT<br>If-None-Match: &quot;948c6463e014712e4df554f4c14ed62c&quot;</td><td>Expires:Wed, 17 Apr 2024 02:28:49GMT<br>Etag:&quot;948c6463e014712e4df554f4c14ed62c&quot;<br>Last-Modified:Thu, 11 Apr 2024 02:45:32 GMT<br>Cache-Control:max-age=86400</td><td>否</td></tr><tr><td>硬性重新加载(command+shift+r)</td><td>Cache-Control:no-cache<br>Pragma:no-cache</td><td>Expires: Wed, 17 Apr 2024 02:28:49 GMT<br>Cache-Control: max-age=86400<br>Etag: &quot;948c6463e014712e4df554f4c14ed62c&quot;<br>Last-Modified:Thu, 11 Apr 2024 02:45:32 GMT</td><td>否</td></tr><tr><td>清空缓存并硬性重新加载</td><td>Cache-Control:no-cache<br>Pragma:no-cache</td><td>Expires: Wed, 17 Apr 2024 02:28:49 GMT<br>Cache-Control: max-age=86400<br>Etag: &quot;948c6463e014712e4df554f4c14ed62c&quot;<br>Last-Modified:Thu, 11 Apr 2024 02:45:32 GMT</td><td>是</td></tr></tbody></table><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://juejin.cn/post/7221750009141526565" target="_blank" rel="noreferrer">【5000字】带你了解透彻浏览器缓存！</a><br><a href="https://bitsup.blogspot.com/2016/05/cache-control-immutable.html" target="_blank" rel="noreferrer">facebook immutable</a><br><a href="https://engineering.fb.com/2017/01/26/web/this-browser-tweak-saved-60-of-requests-to-facebook/" target="_blank" rel="noreferrer">这一浏览器调整节省了60%的Facebook请求</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching" target="_blank" rel="noreferrer">http缓存 mdn</a></p>',45),p=[d];function h(c,i,l,b,m,u){return t(),e("div",null,p)}const k=a(o,[["render",h]]);export{g as __pageData,k as default};
