import{_ as a,o as e,c as s,V as o}from"./chunks/framework.b8955dba.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser/heuristicCaching.md","filePath":"browser/heuristicCaching.md"}'),t={name:"browser/heuristicCaching.md"},n=o(`<h2 id="_1-什么是浏览器的启发式缓存-heuristic-caching" tabindex="-1">1. 什么是浏览器的启发式缓存（Heuristic Caching）？ <a class="header-anchor" href="#_1-什么是浏览器的启发式缓存-heuristic-caching" aria-label="Permalink to &quot;1. 什么是浏览器的启发式缓存（Heuristic Caching）？&quot;">​</a></h2><p>当 HTTP 响应头 没有明确的缓存控制指令（如 Cache-Control 或 Expires）时，浏览器可能会根据启发式算法来决定缓存策略。这种缓存机制通常基于 Last-Modified 头信息进行推测。</p><h2 id="_2-启发式缓存的触发条件" tabindex="-1">2. 启发式缓存的触发条件 <a class="header-anchor" href="#_2-启发式缓存的触发条件" aria-label="Permalink to &quot;2. 启发式缓存的触发条件&quot;">​</a></h2><p>浏览器通常在 响应头中缺少明确的缓存控制策略 时触发启发式缓存，以下情况可能会导致启发式缓存生效：</p><h3 id="_1-响应头没有-cache-control-或-expires" tabindex="-1">（1）响应头没有 Cache-Control 或 Expires <a class="header-anchor" href="#_1-响应头没有-cache-control-或-expires" aria-label="Permalink to &quot;（1）响应头没有 Cache-Control 或 Expires&quot;">​</a></h3><p>如果服务器返回的响应头没有 Cache-Control 或 Expires，但包含 Last-Modified，浏览器可能会使用 Last-Modified 来计算缓存的有效期。</p><h3 id="_2-启发式算法的计算方法-常见规则" tabindex="-1">（2）启发式算法的计算方法（常见规则） <a class="header-anchor" href="#_2-启发式算法的计算方法-常见规则" aria-label="Permalink to &quot;（2）启发式算法的计算方法（常见规则）&quot;">​</a></h3><p>不同的浏览器有不同的启发式缓存策略，但常见的启发式算法如下：</p><p>有效期=(当前时间−Last-Modified 时间)×10% 示例</p><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#F07178;">Date</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">Mon, 22 Jan 2024 12:00:00 GMT</span></span>
<span class="line"><span style="color:#F07178;">Last-Modified</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">Mon, 15 Jan 2024 12:00:00 GMT</span></span></code></pre></div><p>Last-Modified 时间为 7 天前 推测的缓存有效期 ≈ 7 天 × 10% = 0.7 天（约 16 小时 48 分钟） 浏览器可能会缓存该资源 约 16.8 小时，之后才会重新请求服务器。</p><h2 id="_3-启发式缓存是否可靠" tabindex="-1">3. 启发式缓存是否可靠？ <a class="header-anchor" href="#_3-启发式缓存是否可靠" aria-label="Permalink to &quot;3. 启发式缓存是否可靠？&quot;">​</a></h2><p>不太可靠，主要有以下原因：</p><h3 id="_1-不同浏览器实现不同" tabindex="-1">（1）不同浏览器实现不同 <a class="header-anchor" href="#_1-不同浏览器实现不同" aria-label="Permalink to &quot;（1）不同浏览器实现不同&quot;">​</a></h3><p>Chrome、Firefox、Edge 可能使用 10% 规则 计算缓存时间。 Safari 可能有不同的缓存计算方式，甚至可能直接禁用某些资源的启发式缓存。</p><h3 id="_2-可能导致过期资源被错误缓存" tabindex="-1">（2）可能导致过期资源被错误缓存 <a class="header-anchor" href="#_2-可能导致过期资源被错误缓存" aria-label="Permalink to &quot;（2）可能导致过期资源被错误缓存&quot;">​</a></h3><p>如果服务器返回的是经常变化的数据（如 API 响应、动态页面），但没有 Cache-Control 头，浏览器可能错误地缓存过时的资源。</p><h3 id="_3-影响更新速度" tabindex="-1">（3）影响更新速度 <a class="header-anchor" href="#_3-影响更新速度" aria-label="Permalink to &quot;（3）影响更新速度&quot;">​</a></h3><p>由于浏览器自己决定缓存时间，开发者无法精准控制资源的更新频率，可能导致用户看到旧版本资源。</p><h2 id="_4-如何避免启发式缓存" tabindex="-1">4. 如何避免启发式缓存？ <a class="header-anchor" href="#_4-如何避免启发式缓存" aria-label="Permalink to &quot;4. 如何避免启发式缓存？&quot;">​</a></h2><p>如果你想避免启发式缓存，最好明确设置 Cache-Control 头。例如：</p><h3 id="_1-完全禁止缓存" tabindex="-1">（1）完全禁止缓存 <a class="header-anchor" href="#_1-完全禁止缓存" aria-label="Permalink to &quot;（1）完全禁止缓存&quot;">​</a></h3><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F07178;">Cache-Control</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">no-store, no-cache, must-revalidate</span></span>
<span class="line"><span style="color:#F07178;">Pragma</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">no-cache</span></span>
<span class="line"><span style="color:#F07178;">Expires</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">0</span></span></code></pre></div><p>适用于动态内容，如 API 响应、登录页面等。</p><h3 id="_2-指定缓存时间" tabindex="-1">（2）指定缓存时间 <a class="header-anchor" href="#_2-指定缓存时间" aria-label="Permalink to &quot;（2）指定缓存时间&quot;">​</a></h3><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F07178;">Cache-Control</span><span style="color:#F78C6C;">:</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">max-age=3600</span></span></code></pre></div><p>适用于静态资源，明确指定缓存 1 小时（3600 秒）。</p><h3 id="_3-使用-etag-进行缓存验证" tabindex="-1">（3）使用 ETag 进行缓存验证 <a class="header-anchor" href="#_3-使用-etag-进行缓存验证" aria-label="Permalink to &quot;（3）使用 ETag 进行缓存验证&quot;">​</a></h3><p>http 复制 编辑 ETag: &quot;abc123&quot; 让浏览器发送 If-None-Match 请求头来检查资源是否更新。</p><h2 id="_5-总结" tabindex="-1">5. 总结 <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;5. 总结&quot;">​</a></h2><p>特点 行为 触发条件 服务器未提供 Cache-Control 或 Expires，但有 Last-Modified 计算方式 缓存时间 ≈ (当前时间 - Last-Modified) × 10%（不同浏览器可能不同） 可靠性 不可靠，不同浏览器策略不同，可能缓存过期资源 如何避免 显式设置 Cache-Control 头，禁止或精确控制缓存策略</p><p>🔹 最佳实践：始终显式设置 Cache-Control，避免依赖启发式缓存。</p>`,32),l=[n];function r(i,p,c,h,d,C){return e(),s("div",null,l)}const b=a(t,[["render",r]]);export{u as __pageData,b as default};
