import{_ as a,o as e,c as t,V as s}from"./chunks/framework.b8955dba.js";const i="/assets/bianyi.a8ad3e6a.png",r="/assets/jsRun.d95c605d.png",f=JSON.parse('{"title":"js执行机制","description":"","frontmatter":{},"headers":[],"relativePath":"browser/jsRun.md","filePath":"browser/jsRun.md"}'),o={name:"browser/jsRun.md"},l=s('<h1 id="js执行机制" tabindex="-1">js执行机制 <a class="header-anchor" href="#js执行机制" aria-label="Permalink to &quot;js执行机制&quot;">​</a></h1><p>V8 对JavaScript 代码先编译后执行， 1、生成 AST 和执行上下文 2、再基于 AST 生成字节码， 3、然后通过解释器执行字节码 4、如果一段字节码执行比较频繁会通过编 译器转成二进制(机器码)方便执行，这种技术称为即时编译（JIT）。</p><p><img src="'+i+'" alt="编译"><img src="'+r+'" alt="编译"></p><h2 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h2><p>执行上下文中包含了变量环境、词法环境、作用域链(outer)、this</p><h3 id="变量对象" tabindex="-1">变量对象 <a class="header-anchor" href="#变量对象" aria-label="Permalink to &quot;变量对象&quot;">​</a></h3><p>变量对象中包含了变量、函数声明、形参(参数列表)等。变量提升的原因是，在代码执行前，先在执行上下文的变量对象中声明了变量和函数。</p><h3 id="词法环境" tabindex="-1">词法环境 <a class="header-anchor" href="#词法环境" aria-label="Permalink to &quot;词法环境&quot;">​</a></h3><p>词法环境中包含了用let、const声明的变量。变量在其中以栈结构的形式存储避免不同块级作用域的变量相互污染。</p><h3 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h3><p>词法作用域和动态作用域的区别，词法作用域是在代码编译阶段确定的，而动态作用域是在代码执行阶段确定的。</p><p>js是词法作用域，作用域是由代码中函数声明的位置决定的。</p><p>作用域链是由执行上下文中的词法环境、变量环境中的变量、外部环境中的变量组成。当访问一个变量时，会先从当前词法环境中查找，找不到会去变量环境中查找，如果找不到，则从外部环境中的变量中查找，直到全局环境中的变量。</p><h3 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h3><p>this的指向取决于函数的调用方式，有四种情况：</p><ol><li>作为对象的方法调用，this指向该对象</li><li>作为普通函数调用，this指向全局对象</li><li>作为构造函数调用，this指向新创建的对象</li><li>使用call、apply、bind方法调用，this指向指定的对象</li></ol><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p>函数a返回函数b同时函数b又能访问函数a中的变量，我们就把这些变量叫做函数a的闭包。</p><p>闭包的作用是延长变量的生命周期，使得函数a中的变量在函数a执行完毕后仍然可以被访问。</p><p>闭包的缺点是会占用更多的内存，因为闭包中的变量不会被垃圾回收机制回收容易造成<code>内存泄漏</code>。</p>',20),h=[l];function n(c,p,d,_,u,b){return e(),t("div",null,h)}const q=a(o,[["render",n]]);export{f as __pageData,q as default};
