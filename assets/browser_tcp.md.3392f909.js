import{_ as l,o as t,c as e,V as a}from"./chunks/framework.b8955dba.js";const u=JSON.parse('{"title":"TCP 建立链接和断开链接的详细流程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/tcp.md","filePath":"browser/tcp.md"}'),o={name:"browser/tcp.md"},i=a('<h1 id="tcp-建立链接和断开链接的详细流程" tabindex="-1">TCP 建立链接和断开链接的详细流程 <a class="header-anchor" href="#tcp-建立链接和断开链接的详细流程" aria-label="Permalink to &quot;TCP 建立链接和断开链接的详细流程&quot;">​</a></h1><p>TCP（传输控制协议）是一种面向连接的、可靠的传输层协议，其建立连接和断开连接都有严谨的流程。</p><h2 id="tcp-建立连接-三次握手" tabindex="-1">TCP 建立连接（三次握手） <a class="header-anchor" href="#tcp-建立连接-三次握手" aria-label="Permalink to &quot;TCP 建立连接（三次握手）&quot;">​</a></h2><ol><li>第一次握手（客户端发起 SYN）：</li></ol><ul><li>客户端向服务器发送一个 SYN（同步序列号，Synchronize Sequence Numbers）报文段。这个报文段包含一个随机生成的初始序列号（Sequence Number，简称 SEQ），假设为 x。此报文段的目的是向服务器表明客户端想要建立连接，并告知服务器自己的初始序列号。客户端进入 SYN_SENT 状态，表示已发送同步请求。</li></ul><ol start="2"><li>第二次握手（服务器回应 SYN + ACK）：</li></ol><ul><li>服务器接收到客户端的 SYN 报文段后，会向客户端发送一个 SYN + ACK 报文段作为回应。该报文段中，SYN 部分同样包含服务器自己生成的一个随机初始序列号，假设为 y；ACK 部分是对客户端 SYN 报文段的确认，确认号（Acknowledgment Number，简称 ACK）为 x+1，表示服务器已经收到客户端的 SYN 报文，期望客户端下一次发送的数据从序列号 x+1开始。服务器此时进入 SYN_RCVD 状态，表示已收到客户端的同步请求并做出响应。</li></ul><ol start="3"><li>第三次握手（客户端发送 ACK）： 客户端收到服务器的 SYN + ACK 报文段后，会向服务器发送一个 ACK 确认报文段。此报文段的确认号为 y+1，表示客户端已经收到服务器的 SYN 报文，期望服务器下一次发送的数据从序列号 y+1开始。序列号为 x+1，这是根据之前发送的 SYN 报文段的序列号递增而来。客户端发送完这个 ACK 报文段后进入 ESTABLISHED 状态，表示连接已成功建立，可以开始传输数据。服务器收到这个 ACK 报文段后也进入 ESTABLISHED 状态。</li></ol><h2 id="tcp-断开连接-四次挥手" tabindex="-1">TCP 断开连接（四次挥手） <a class="header-anchor" href="#tcp-断开连接-四次挥手" aria-label="Permalink to &quot;TCP 断开连接（四次挥手）&quot;">​</a></h2><ol><li>第一次挥手（客户端发送 FIN）：</li></ol><ul><li>当客户端数据传输完毕，想要关闭连接时，会向服务器发送一个 FIN（结束，Finish）报文段。这个报文段的序列号为 u，它表示客户端已经没有数据要发送给服务器了，但客户端仍然可以接收服务器发送的数据。客户端发送完 FIN 报文段后进入 FIN_WAIT_1 状态。</li></ul><ol start="2"><li>第二次挥手（服务器回应 ACK）：</li></ol><ul><li>服务器接收到客户端的 FIN 报文段后，会向客户端发送一个 ACK 确认报文段。此报文段的确认号为 u+1，表示服务器已经收到客户端的 FIN 报文。序列号为 v，这是服务器当前的序列号。服务器发送完这个 ACK 报文段后进入 CLOSE_WAIT 状态。客户端收到这个 ACK 报文段后进入 FIN_WAIT_2 状态。此时，从客户端到服务器的连接已经关闭，但服务器到客户端的连接仍然是打开的，服务器还可以继续向客户端发送数据。</li></ul><ol start="3"><li>第三次挥手（服务器发送 FIN）：</li></ol><ul><li>当服务器数据也传输完毕后，会向客户端发送一个 FIN 报文段。这个报文段的序列号为 w，确认号仍然为 u+1。服务器发送完这个 FIN 报文段后进入 LAST_ACK 状态。此 FIN 报文段表示服务器也没有数据要发送给客户端了。</li></ul><ol start="4"><li>第四次挥手（客户端回应 ACK）： 客户端接收到服务器的 FIN 报文段后，会向服务器发送一个 ACK 确认报文段。此报文段的确认号为 w+1，序列号为 u+1。客户端发送完这个 ACK 报文段后进入 TIME_WAIT 状态。服务器收到这个 ACK 报文段后，连接正式关闭，进入 CLOSED 状态。客户端在 TIME_WAIT 状态停留一段时间（通常为 2MSL，MSL 是最长报文段寿命），以确保最后一个 ACK 报文能够被服务器成功接收，若期间没有收到服务器的重传请求，客户端也进入 CLOSED 状态，连接彻底断开。</li></ol>',16),r=[i];function c(s,_,n,C,S,N){return t(),e("div",null,r)}const T=l(o,[["render",c]]);export{u as __pageData,T as default};
