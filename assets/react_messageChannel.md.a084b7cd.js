import{_ as a,o as s,c as e,V as n}from"./chunks/framework.b8955dba.js";const m=JSON.parse('{"title":"react为什么选择MessageChannel来让出执行权?","description":"","frontmatter":{},"headers":[],"relativePath":"react/messageChannel.md","filePath":"react/messageChannel.md"}'),l={name:"react/messageChannel.md"},o=n(`<h1 id="react为什么选择messagechannel来让出执行权" tabindex="-1">react为什么选择MessageChannel来让出执行权? <a class="header-anchor" href="#react为什么选择messagechannel来让出执行权" aria-label="Permalink to &quot;react为什么选择MessageChannel来让出执行权?&quot;">​</a></h1><h2 id="帧率" tabindex="-1">帧率 <a class="header-anchor" href="#帧率" aria-label="Permalink to &quot;帧率&quot;">​</a></h2><p>我们一般所理解的动画，是一帧一帧的图片就行快速切换得到的。</p><p>一般浏览器是60帧，即1s渲染60次，16.666ms一帧。</p><p>而人的眼睛，一般20帧左右，就可以感觉到比较流畅的动画了。</p><h2 id="浏览器在一帧里-做了哪些事情呢" tabindex="-1">浏览器在一帧里，做了哪些事情呢? <a class="header-anchor" href="#浏览器在一帧里-做了哪些事情呢" aria-label="Permalink to &quot;浏览器在一帧里，做了哪些事情呢?&quot;">​</a></h2><p>宏任务 | 微任务 | requestAnimationFrameWork | layout 绘制 | requestIdleCallback</p><p>如果某一次渲染任务，超过了16.666ms，那么就会导致掉帧。例如动画卡顿、输入延迟等。</p><h2 id="怎么避免卡顿" tabindex="-1">怎么避免卡顿 <a class="header-anchor" href="#怎么避免卡顿" aria-label="Permalink to &quot;怎么避免卡顿&quot;">​</a></h2><p>把任务进行切片，然后在每一帧的layout 绘制之后执行任务切片(这一帧率渲染后或者下一帧的开始执行)</p><h2 id="为何不用requestidlecallback" tabindex="-1">为何不用requestIdleCallback <a class="header-anchor" href="#为何不用requestidlecallback" aria-label="Permalink to &quot;为何不用requestIdleCallback&quot;">​</a></h2><ul><li>兼容性差 Safari 并不支持</li><li>优先级 requestIdleCallback 是浏览器提供的在空闲时段执行低优先级任务的 API，如果有其他高优先级的任务，则会推迟执行。requestIdleCallback(idleTask, { timeout: 50 });）如果不设置timeout, 在极端情况下，如果浏览器一直处于繁忙状态，任务甚至可能永远无法执行.</li></ul><h2 id="为何不使用settimeout" tabindex="-1">为何不使用setTimeout? <a class="header-anchor" href="#为何不使用settimeout" aria-label="Permalink to &quot;为何不使用setTimeout?&quot;">​</a></h2><p>setTimeout如果嵌套超过5层，则会强制有4s的时间间隔</p><h2 id="为何不使用promise" tabindex="-1">为何不使用Promise <a class="header-anchor" href="#为何不使用promise" aria-label="Permalink to &quot;为何不使用Promise&quot;">​</a></h2><p>Promise 是微任务，微任务是在当前帧layout之前执行会导致卡顿</p><h2 id="messagechannel" tabindex="-1">messageChannel <a class="header-anchor" href="#messagechannel" aria-label="Permalink to &quot;messageChannel&quot;">​</a></h2><p>messageChannel是个宏任务，会在下一帧的开始执行，不会导致卡顿。</p><p>MessageChannel 是一个消息通道，它允许我们在两个不同的上下文之间传递消息。我们可以使用 MessageChannel 来实现一个简单的任务调度器，它可以在每一帧的 layout 绘制之后执行任务切片。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> channel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">MessageChannel</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> port1 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> channel</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">port1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> port2 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> channel</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">port2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">port1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onmessage</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 在下一帧执行任务切片</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 在这一帧将任务切片发送到 port2</span></span>
<span class="line"><span style="color:#BABED8;">port2</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">postMessage</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">null</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div>`,20),t=[o];function p(r,c,i,h,D,y){return s(),e("div",null,t)}const u=a(l,[["render",p]]);export{m as __pageData,u as default};
