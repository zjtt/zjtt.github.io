import{_ as e,o as r,c,V as a}from"./chunks/framework.b8955dba.js";const k=JSON.parse('{"title":"react 的两种调和器 stack reconciler 与fiber reconciler","description":"","frontmatter":{},"headers":[],"relativePath":"react/other/2.md","filePath":"react/other/2.md"}'),i={name:"react/other/2.md"},t=a('<h1 id="react-的两种调和器-stack-reconciler-与fiber-reconciler" tabindex="-1">react 的两种调和器 stack reconciler 与fiber reconciler <a class="header-anchor" href="#react-的两种调和器-stack-reconciler-与fiber-reconciler" aria-label="Permalink to &quot;react 的两种调和器 stack reconciler 与fiber reconciler&quot;">​</a></h1><h2 id="stack-reconciler-栈调和器" tabindex="-1">stack reconciler（栈调和器） <a class="header-anchor" href="#stack-reconciler-栈调和器" aria-label="Permalink to &quot;stack reconciler（栈调和器）&quot;">​</a></h2><p>react 15 的reconciler 是stack reconciler，它是一个同步的递归过程，当组件更新时，会递归遍历组件树，更新每一个组件的状态，然后重新渲染整个组件树。这个过程是同步的，如果在渲染过程中遇到了耗时的操作（例如计算大量数据或者执行复杂的DOM操作），就会导致整个应用的卡顿。</p><h3 id="工作原理" tabindex="-1">工作原理： <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理：&quot;">​</a></h3><ul><li><p>Stack Reconciler 是 React 早期版本（React v15 及之前）使用的调和算法。在这个机制下，当组件状态或属性发生变化时，React 会递归地遍历虚拟 DOM 树，这个递归过程就像在一个调用栈中进行操作，所以被称为 “栈调和器”。</p></li><li><p>例如，当顶层组件更新时，React 会从根节点开始，深度优先遍历整棵虚拟 DOM 树，比较新老虚拟 DOM 树的差异。在遍历过程中，每进入一个新的节点，就如同将该节点的处理逻辑压入调用栈；处理完该节点后，又如同从调用栈中弹出。</p></li></ul><h3 id="存在的问题" tabindex="-1">存在的问题： <a class="header-anchor" href="#存在的问题" aria-label="Permalink to &quot;存在的问题：&quot;">​</a></h3><ul><li>阻塞主线程：由于采用递归方式遍历虚拟 DOM 树，在复杂的应用中，当有大量的节点需要更新时，这个过程会持续占用 JavaScript 主线程，导致主线程无法处理其他任务，如用户交互、动画渲染等。这会使应用出现卡顿现象，影响用户体验。例如，一个包含大量列表项的长列表组件更新时，用户可能会感觉到界面失去响应。</li></ul><h2 id="fiber-reconciler-纤程调和器" tabindex="-1">fiber reconciler（纤程调和器） <a class="header-anchor" href="#fiber-reconciler-纤程调和器" aria-label="Permalink to &quot;fiber reconciler（纤程调和器）&quot;">​</a></h2><p>react 16 的reconciler 是fiber reconciler，它是一个异步的过程，将整个渲染过程拆分成多个小的任务，每个任务只处理一部分组件的更新，然后让出控制权给浏览器，让浏览器可以执行其他任务（例如响应用户输入或者执行动画）。当浏览器有空闲时间时，react 会继续执行剩下的任务，直到整个渲染过程完成。这个过程是异步的，可以避免在渲染过程中阻塞主线程，从而提高应用的性能。</p><h3 id="fiber-的概念" tabindex="-1">Fiber 的概念： <a class="header-anchor" href="#fiber-的概念" aria-label="Permalink to &quot;Fiber 的概念：&quot;">​</a></h3><p>Fiber 是 React v16 引入的一种新的数据结构，它代表了虚拟 DOM 树中的一个节点。每个 Fiber 节点包含了有关组件、其对应的 DOM 元素以及处理副作用（如 DOM 更新、生命周期方法调用等）的信息。Fiber 可以被视为一个 “工作单元”，每个 Fiber 节点可以暂停、恢复和复用其工作。</p><h3 id="工作原理-1" tabindex="-1">工作原理： <a class="header-anchor" href="#工作原理-1" aria-label="Permalink to &quot;工作原理：&quot;">​</a></h3><ul><li>任务切片：Fiber Reconciler 将更新任务拆分成多个小的任务单元（即 Fiber 节点对应的工作），这些任务单元可以在主线程空闲时逐步执行，而不是像 Stack Reconciler 那样一次性完成整个更新过程。例如，React 会根据浏览器的空闲时间，在每一帧中合理分配时间来处理这些任务单元。如果在处理某个任务单元时，浏览器需要处理其他紧急任务（如响应用户输入），React 可以暂停当前任务，将控制权交还给主线程，等主线程空闲时再继续处理剩余的任务。</li><li>可中断与恢复：在遍历 Fiber 树（即执行更新任务）的过程中，React 可以随时中断当前的工作，去处理更高优先级的任务，如用户事件。当高优先级任务处理完后，React 能够从上次中断的地方恢复继续执行更新任务。这种可中断与恢复的特性是 Fiber Reconciler 的核心优势之一。</li><li>优先级调度：Fiber Reconciler 引入了优先级调度机制。不同类型的更新任务（如用户交互引起的更新、数据获取完成后的更新等）会被赋予不同的优先级。React 会优先处理高优先级的任务，确保用户交互的即时响应。例如，用户点击按钮触发的更新会比一个数据接口返回后触发的更新具有更高的优先级，这样能保证界面的流畅性和响应性。</li></ul><h3 id="生命周期方法的变化" tabindex="-1">生命周期方法的变化 <a class="header-anchor" href="#生命周期方法的变化" aria-label="Permalink to &quot;生命周期方法的变化&quot;">​</a></h3><p>为了适应 Fiber 架构的特性，一些 React 类组件的生命周期方法发生了变化或被标记为不安全（如componentWillMount、componentWillReceiveProps、componentWillUpdate等被标记为UNSAFE_前缀的方法），开发者需要使用新的生命周期方法或 Hooks 来实现相同的功能。例如，getDerivedStateFromProps和getSnapshotBeforeUpdate等方法在 Fiber 架构下提供了更可控的状态更新和 DOM 操作时机。</p><h2 id="stack-reconciler-与fiber-reconciler-的区别" tabindex="-1">stack reconciler 与fiber reconciler 的区别 <a class="header-anchor" href="#stack-reconciler-与fiber-reconciler-的区别" aria-label="Permalink to &quot;stack reconciler 与fiber reconciler 的区别&quot;">​</a></h2><p>stack reconciler 是同步的递归过程，而fiber reconciler 是异步的过程。stack reconciler 在渲染过程中会阻塞主线程，而fiber reconciler 可以在渲染过程中让出控制权给浏览器，从而提高应用的性能。另外，fiber reconciler 还可以中断和恢复渲染过程，这样可以更好地处理长任务和动画，从而提高应用的响应速度。</p>',17),o=[t];function l(n,s,h,b,d,f){return r(),c("div",null,o)}const u=e(i,[["render",l]]);export{k as __pageData,u as default};
